# 파이썬 벤치마크 테스트

파이썬 코드로 CPU, 메모리, 하드디스크 IO 등에 해하여 벤치마크를 진행하고 픈데 뭐가 있을까 찾아보기도 하였습니다.
특별한 것은 안 보이더군요.

그러다가 [pytest-benchmark](http://pytest-benchmark.readthedocs.io/en/stable/) 라는 것을 발견하였습니다.

뭐가 뭘까 궁금해 하다가 테스트를 해 보고 그 정도만 공유해 봅니다. 더 발전시켜 보실 분들은 기꺼이 가져다 사용하십시오.

## 설치

```sh
$ sudo pip install virtualenv
$ virtualenv -p python /opt/python2 # virtualenv 를 생활화 합시다 ^^
$ source /opt/python2/bin/activate
(python2) $ pip install pytest-benchmark
```

위와 같이 명령을 입력하거나 [build.sh](build.sh) 를 참고 하십시오.

## python test program

작성하는 방법인데 다음과 같이 시도를 해 봅니다.

``` python
##########################################################################################
class cpu_bench(object):
    #=====================================================================================
    @staticmethod
    def seq_sum_loop(loop=LOOP):
        _sum = 0
        for i in xrange(loop):
            _sum += i
        return loop, _sum
        
##########################################################################################
def test_cpu_seq_sum_loop(benchmark):
    benchmark.pedantic(cpu_bench.seq_sum_loop, iterations=ITERATIONS, rounds=ROUNDS)
```

위의 파일을 [pybench.py](pybench.py) 라고 저장해 봅니다.

import 도 없고 이게 뭐지 했는데 실행은

```sh
$ pytest pybench.py
```
와 같은 식으로 작성하면 됩니다.

실제 loop을 돌면서 반복문 계산 (CPU), 또한 list와 dictionary 를 돌면서 sequential 접근 및 랜덤 접근을 해 보거나 (Memory) 파일에 대해서도 해당 블럭 크기만큼 돌면서 순차적 또는 랜덤 파일 입출력을 해 봅니다.

추가된 전체 파일은 [pybench.py](pybench.py)을 참고 하십시오.

## 실행 결과

[run.sh](run.sh) 를 실행시키면 

```sh 
$ ./run.sh 
====================================================================================================== test session starts =======================================================================================================
platform linux2 -- Python 2.7.12, pytest-3.0.3, py-1.4.31, pluggy-0.4.0
benchmark: 3.0.0 (defaults: timer=time.time disable_gc=False min_rounds=5 min_time=5.00us max_time=1.00s calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/future/work/test/benchmark, inifile: 
plugins: benchmark-3.0.0
collected 12 items 

pybench.py ............

Saved benchmark data in /home/future/work/test/benchmark/.benchmarks/Linux-CPython-2.7-64bit/0002_unversioned_20161025_142432.json

------------------------------------------------------------------------------------------------- benchmark: 12 tests -------------------------------------------------------------------------------------------------
Name (time in us)                        Min                       Max                      Mean                  StdDev                    Median                       IQR            Outliers(*)  Rounds  Iterations
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_cpu_seq_sum_loop               514.3642 (1.0)            521.6122 (1.0)            517.5908 (1.0)            3.6887 (1.0)            516.7961 (1.0)              5.4359 (1.0)              1;0       3           5
test_mem_list_seq_op              1,791.1911 (3.48)         1,816.6065 (3.48)         1,800.2033 (3.48)          14.2287 (3.86)         1,792.8123 (3.47)            19.0616 (3.51)             1;0       3           5
test_mem_list_rnd_op              1,880.5981 (3.66)         1,916.7900 (3.67)         1,894.3310 (3.66)          19.6105 (5.32)         1,885.6049 (3.65)            27.1440 (4.99)             1;0       3           5
test_mem_hash_seq_op              7,563.5910 (14.70)        7,607.7938 (14.59)        7,579.0087 (14.64)         24.9497 (6.76)         7,565.6414 (14.64)           33.1521 (6.10)             1;0       3           5
test_mem_hash_rnd_op              8,177.5665 (15.90)        8,338.4037 (15.99)        8,254.0671 (15.95)         80.7044 (21.88)        8,246.2311 (15.96)          120.6279 (22.19)            1;0       3           5
test_cpu_rnd_sum_loop            15,553.5698 (30.24)       15,580.8449 (29.87)       15,567.8113 (30.08)         13.6776 (3.71)        15,569.0193 (30.13)           20.4563 (3.76)             1;0       3           5
test_cpu_seq_sum_now_loop        54,509.0199 (105.97)      54,823.8277 (105.10)      54,706.6847 (105.69)       172.1593 (46.67)       54,787.2066 (106.01)         236.1059 (43.43)            1;0       3           5
test_cpu_fiboncci_loop          106,644.8212 (207.33)     106,662.3688 (204.49)     106,652.7208 (206.06)         8.9035 (2.41)       106,650.9724 (206.37)          13.1607 (2.42)             1;0       3           5
test_io_read_rnd_op             279,570.7703 (543.53)     280,136.2038 (537.06)     279,764.4456 (540.51)       322.0464 (87.31)      279,586.3628 (541.00)         424.0751 (78.01)            1;0       3           5
test_io_write_seq_op            468,400.0015 (910.64)   1,886,030.9601 (>1000.0)  1,236,533.9279 (>1000.0)  716,223.0226 (>1000.0)  1,355,170.8221 (>1000.0)  1,063,223.2189 (>1000.0)          1;0       3           5
test_io_write_rnd_op            838,874.5785 (>1000.0)  1,186,038.0173 (>1000.0)    954,789.5432 (>1000.0)  200,267.2642 (>1000.0)    839,456.0337 (>1000.0)    260,372.5791 (>1000.0)          1;0       3           5
test_io_read_seq_op           1,103,598.9761 (>1000.0)  1,109,051.4183 (>1000.0)  1,106,902.4563 (>1000.0)    2,903.7847 (787.20)   1,108,056.9744 (>1000.0)      4,089.3316 (752.28)           1;0       3           5
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

(*) Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.
=================================================================================================== 12 passed in 60.15 seconds ===================================================================================================

```

와 같은 식으로 결과가 나옵니다.

제일 적게 걸린 함수부터 나오는데 (마이크로 세컨드) 단위입니다.  15,553.5698 와 같은 것이 실제로는 1.5... 초 입니다.

Rounds와 Iterations을 주었는데 아직 차이는 잘 모르겠습니다. 자세히 파악하신 분은 알려주십시오.

## ToDo

위와 동일한 코드를 각 머신 또는 장치에서 실행하여 그 각각을 비교하면 어떤 장비에는 어떻고 다른 장비는 어떻고 하는 특성이 나올 것입니다. 예를 들어 어떤 장비는 특별히 IO의 random write가 느릴 수 있고, 다른 장비는 메모리 random read가 느릴 수 있을 것입니다. 그것은 위와 같은 결과의 수행 시간을 보고 판단할 수 있습니다.

각각의 수행결과는 json으로 떨어지며 이것을 가지고 비교할 수 있다고 나오네요.

해 보신 분은 알려주십시오.


고맙습니다.

어떤분께는 도움이 되셨기를.... 
